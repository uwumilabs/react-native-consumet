// Auto-generated from test.js
export const testCodeString =
  "\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction createAnimeKai(ctx, customBaseURL) {\n    const { axios, load, enums, createCustomBaseUrl, USER_AGENT, PolyURL, extractors } = ctx;\n    const { StreamingServers: StreamingServersEnum, MediaStatus: MediaStatusEnum, SubOrDub: SubOrDubEnum } = enums;\n    const { MegaUp } = extractors;\n    const baseUrl = createCustomBaseUrl('https://anikai.to', customBaseURL);\n    const apiBase = 'https://enc-dec.app/api';\n    const config = {\n        name: 'AnimeKai',\n        languages: 'en',\n        classPath: 'ANIME.AnimeKai',\n        logo: 'https://anikai.to/assets/uploads/37585a3ffa8ec292ee9e2255f3f63b48ceca17e5241280b3dc21.png',\n        baseUrl,\n        isNSFW: false,\n        isWorking: true,\n        isDubAvailableSeparately: true,\n    };\n    const buildHeaders = () => ({\n        'User-Agent': USER_AGENT ||\n            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36',\n        'Connection': 'keep-alive',\n        'Accept': 'text/html, */*; q=0.01',\n        'Accept-Language': 'en-US,en;q=0.5',\n        'Sec-GPC': '1',\n        'Sec-Fetch-Dest': 'empty',\n        'Sec-Fetch-Mode': 'cors',\n        'Sec-Fetch-Site': 'same-origin',\n        'Priority': 'u=0',\n        'Pragma': 'no-cache',\n        'Cache-Control': 'no-cache',\n        'Referer': `${config.baseUrl}/`,\n        'Cookie': '__p_mov=1; usertype=guest; session=vLrU4aKItp0QltI2asH83yugyWDsSSQtyl9sxWKO',\n    });\n    const normalizePage = (page = 1) => (page <= 0 ? 1 : page);\n    const scrapeCard = ($) => __awaiter(this, void 0, void 0, function* () {\n        const results = [];\n        $('.aitem').each((_, element) => {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n            const card = $(element);\n            const anchor = card.find('div.inner > a');\n            const id = (_a = anchor.attr('href')) === null || _a === void 0 ? void 0 : _a.replace('/watch/', '');\n            if (!id)\n                return;\n            const infoElements = card.find('.info').children();\n            const type = (_b = infoElements.last()) === null || _b === void 0 ? void 0 : _b.text().trim();\n            results.push({\n                id,\n                title: anchor.text().trim(),\n                url: `${config.baseUrl}${anchor.attr('href')}`,\n                image: (_f = (_d = (_c = card.find('img')) === null || _c === void 0 ? void 0 : _c.attr('data-src')) !== null && _d !== void 0 ? _d : (_e = card.find('img')) === null || _e === void 0 ? void 0 : _e.attr('src')) !== null && _f !== void 0 ? _f : undefined,\n                japaneseTitle: (_h = (_g = card.find('a.title')) === null || _g === void 0 ? void 0 : _g.attr('data-jp')) === null || _h === void 0 ? void 0 : _h.trim(),\n                type: (_j = type) !== null && _j !== void 0 ? _j : undefined,\n                sub: parseInt(((_k = card.find('.info span.sub')) === null || _k === void 0 ? void 0 : _k.text()) || '0', 10),\n                dub: parseInt(((_l = card.find('.info span.dub')) === null || _l === void 0 ? void 0 : _l.text()) || '0', 10),\n                episodes: parseInt(infoElements.eq(-2).text().trim() || ((_m = card.find('.info span.sub')) === null || _m === void 0 ? void 0 : _m.text()) || '0', 10) || 0,\n            });\n        });\n        return results;\n    });\n    const scrapeCardPage = (url) => __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        const res = {\n            currentPage: 0,\n            hasNextPage: false,\n            totalPages: 0,\n            results: [],\n        };\n        const { data } = yield axios.get(url, { headers: buildHeaders() });\n        const $ = load(data);\n        const pagination = $('ul.pagination');\n        res.currentPage = parseInt(pagination.find('.page-item.active span.page-link').text().trim(), 10) || 0;\n        const nextHref = pagination.find('.page-item.active').next().find('a.page-link').attr('href');\n        res.hasNextPage = Boolean(nextHref && nextHref.includes('page='));\n        const totalHref = pagination.find('.page-item:last-child a.page-link').attr('href');\n        res.totalPages =\n            totalHref && totalHref.includes('page=')\n                ? parseInt((_a = totalHref.split('page=')[1]) !== null && _a !== void 0 ? _a : '0', 10) || 0\n                : res.currentPage;\n        res.results = yield scrapeCard($);\n        if (res.results.length === 0) {\n            res.currentPage = 0;\n            res.hasNextPage = false;\n            res.totalPages = 0;\n        }\n        return res;\n    });\n    const search = (query_1, ...args_1) => __awaiter(this, [query_1, ...args_1], void 0, function* (query, page = 1) {\n        const normalizedPage = normalizePage(page);\n        const sanitizedQuery = query.replace(/[^\\w]+/g, '+');\n        return scrapeCardPage(`${config.baseUrl}/browser?keyword=${sanitizedQuery}&page=${normalizedPage}`);\n    });\n    const fetchLatestCompleted = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        return scrapeCardPage(`${config.baseUrl}/completed?page=${normalizePage(page)}`);\n    });\n    const fetchRecentlyAdded = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        return scrapeCardPage(`${config.baseUrl}/recent?page=${normalizePage(page)}`);\n    });\n    const fetchRecentlyUpdated = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        return scrapeCardPage(`${config.baseUrl}/updates?page=${normalizePage(page)}`);\n    });\n    const fetchNewReleases = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        return scrapeCardPage(`${config.baseUrl}/new-releases?page=${normalizePage(page)}`);\n    });\n    const fetchMovie = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        return scrapeCardPage(`${config.baseUrl}/movie?page=${normalizePage(page)}`);\n    });\n    const fetchTV = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        return scrapeCardPage(`${config.baseUrl}/tv?page=${normalizePage(page)}`);\n    });\n    const fetchOVA = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        return scrapeCardPage(`${config.baseUrl}/ova?page=${normalizePage(page)}`);\n    });\n    const fetchONA = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        return scrapeCardPage(`${config.baseUrl}/ona?page=${normalizePage(page)}`);\n    });\n    const fetchSpecial = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        return scrapeCardPage(`${config.baseUrl}/special?page=${normalizePage(page)}`);\n    });\n    const fetchGenres = () => __awaiter(this, void 0, void 0, function* () {\n        const genres = [];\n        const { data } = yield axios.get(`${config.baseUrl}/home`, { headers: buildHeaders() });\n        const $ = load(data);\n        $('#menu')\n            .find('ul.c4 li a')\n            .each((_, element) => {\n            const genreText = $(element).text().toLowerCase();\n            if (genreText)\n                genres.push(genreText);\n        });\n        return genres;\n    });\n    const genreSearch = (genre_1, ...args_1) => __awaiter(this, [genre_1, ...args_1], void 0, function* (genre, page = 1) {\n        if (!genre) {\n            throw new Error('genre is empty');\n        }\n        return scrapeCardPage(`${config.baseUrl}/genres/${genre}?page=${normalizePage(page)}`);\n    });\n    const fetchSchedule = (...args_1) => __awaiter(this, [...args_1], void 0, function* (date = new Date().toISOString().split('T')[0]) {\n        const res = { results: [] };\n        const scheduleUnix = Math.floor(new Date(`${date}T00:00:00Z`).getTime() / 1000);\n        const { data } = yield axios.get(`${config.baseUrl}/ajax/schedule/items?tz=5.5&time=${scheduleUnix}`, {\n            headers: buildHeaders(),\n        });\n        const $ = load(data.result);\n        $('ul.collapsed li').each((_, element) => {\n            var _a, _b;\n            const card = $(element);\n            const titleElement = card.find('span.title');\n            const episodeText = card.find('span').last().text().trim();\n            const id = (_b = (_a = card.find('a').attr('href')) === null || _a === void 0 ? void 0 : _a.split('/')[2]) !== null && _b !== void 0 ? _b : '';\n            if (!id)\n                return;\n            res.results.push({\n                id,\n                title: titleElement.text().trim(),\n                japaneseTitle: titleElement.attr('data-jp') || undefined,\n                airingTime: card.find('span.time').text().trim(),\n                airingEpisode: episodeText.replace('EP ', ''),\n            });\n        });\n        return res;\n    });\n    const fetchSpotlight = () => __awaiter(this, void 0, void 0, function* () {\n        const res = { results: [] };\n        const { data } = yield axios.get(`${config.baseUrl}/home`, { headers: buildHeaders() });\n        const $ = load(data);\n        $('div.swiper-wrapper > div.swiper-slide').each((_, element) => {\n            var _a, _b, _c;\n            const card = $(element);\n            const titleElement = card.find('div.detail > p.title');\n            const id = ((_a = card.find('div.swiper-ctrl > a.btn').attr('href')) === null || _a === void 0 ? void 0 : _a.replace('/watch/', '')) || '';\n            if (!id)\n                return;\n            const infoElements = card.find('div.detail > div.info').children();\n            res.results.push({\n                id,\n                title: titleElement.text(),\n                japaneseTitle: titleElement.attr('data-jp') || undefined,\n                banner: ((_c = (_b = card.attr('style')) === null || _b === void 0 ? void 0 : _b.match(/background-image:\\s*url\\([\"']?(.+?)[\"']?\\)/)) === null || _c === void 0 ? void 0 : _c[1]) || null,\n                url: `${config.baseUrl}/watch/${id}`,\n                type: infoElements.eq(-2).text().trim(),\n                genres: infoElements\n                    .last()\n                    .text()\n                    .trim()\n                    .split(',')\n                    .map((genre) => genre.trim()),\n                releaseDate: card.find('div.detail > div.mics > div:contains(\"Release\") span').text().trim(),\n                quality: card.find('div.detail > div.mics > div:contains(\"Quality\") span').text().trim(),\n                sub: parseInt(card.find('div.detail > div.info > span.sub').text().trim() || '0', 10),\n                dub: parseInt(card.find('div.detail > div.info > span.dub').text().trim() || '0', 10),\n                description: card.find('div.detail > p.desc').text().trim(),\n            });\n        });\n        return res;\n    });\n    const fetchSearchSuggestions = (query) => __awaiter(this, void 0, void 0, function* () {\n        const { data } = yield axios.get(`${config.baseUrl}/ajax/anime/search?keyword=${query.replace(/[^\\w]+/g, '+')}`, {\n            headers: buildHeaders(),\n        });\n        const $ = load(data.result.html);\n        const res = { results: [] };\n        $('a.aitem').each((_, element) => {\n            var _a, _b, _c, _d;\n            const card = $(element);\n            const id = (_a = card.attr('href')) === null || _a === void 0 ? void 0 : _a.split('/')[2];\n            if (!id)\n                return;\n            const infoElements = card.find('.info').children();\n            const titleElement = card.find('.title');\n            res.results.push({\n                id,\n                title: titleElement.text().trim(),\n                url: `${config.baseUrl}/watch/${id}`,\n                image: card.find('.poster img').attr('src') || undefined,\n                japaneseTitle: titleElement.attr('data-jp') || undefined,\n                type: infoElements.eq(-3).text().trim(),\n                year: infoElements.eq(-2).text().trim(),\n                sub: parseInt(((_b = card.find('.info span.sub')) === null || _b === void 0 ? void 0 : _b.text()) || '0', 10),\n                dub: parseInt(((_c = card.find('.info span.dub')) === null || _c === void 0 ? void 0 : _c.text()) || '0', 10),\n                episodes: parseInt(infoElements.eq(-4).text().trim() || ((_d = card.find('.info span.sub')) === null || _d === void 0 ? void 0 : _d.text()) || '0', 10) || 0,\n            });\n        });\n        return res;\n    });\n    const fetchAnimeInfo = (id) => __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        const info = { id, title: '' };\n        const { data } = yield axios.get(`${config.baseUrl}/watch/${id}`, { headers: buildHeaders() });\n        const $ = load(data);\n        info.title = $('.entity-scroll > .title').text().trim();\n        info.japaneseTitle = (_a = $('.entity-scroll > .title').attr('data-jp')) === null || _a === void 0 ? void 0 : _a.trim();\n        info.image = $('div.poster > div > img').attr('src');\n        info.description = $('.entity-scroll > .desc').text().trim();\n        info.type = $('.entity-scroll > .info').children().last().text().trim().toUpperCase();\n        info.url = `${config.baseUrl}/watch/${id}`;\n        info.recommendations = [];\n        $('section.sidebar-section:not(#related-anime) .aitem-col .aitem').each((_, element) => {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n            const card = $(element);\n            const recommendationId = (_a = card.attr('href')) === null || _a === void 0 ? void 0 : _a.replace('/watch/', '');\n            if (!recommendationId)\n                return;\n            (_b = info.recommendations) === null || _b === void 0 ? void 0 : _b.push({\n                id: recommendationId,\n                title: card.find('.title').text().trim(),\n                url: `${config.baseUrl}${card.attr('href')}`,\n                image: (_e = (_d = (_c = card.attr('style')) === null || _c === void 0 ? void 0 : _c.match(/background-image:\\s*url\\('(.+?)'\\)/)) === null || _d === void 0 ? void 0 : _d[1]) !== null && _e !== void 0 ? _e : undefined,\n                japaneseTitle: (_f = card.find('.title').attr('data-jp')) === null || _f === void 0 ? void 0 : _f.trim(),\n                type: card.find('.info').children().last().text().trim(),\n                sub: parseInt(((_g = card.find('.info span.sub')) === null || _g === void 0 ? void 0 : _g.text()) || '0', 10),\n                dub: parseInt(((_h = card.find('.info span.dub')) === null || _h === void 0 ? void 0 : _h.text()) || '0', 10),\n                episodes: parseInt(card.find('.info').children().eq(-2).text().trim() || ((_j = card.find('.info span.sub')) === null || _j === void 0 ? void 0 : _j.text()) || '0', 10) || 0,\n            });\n        });\n        info.relations = [];\n        $('section#related-anime .tab-body .aitem-col').each((_, element) => {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n            const card = $(element);\n            const relationAnchor = card.find('a.aitem');\n            const relationId = (_a = relationAnchor.attr('href')) === null || _a === void 0 ? void 0 : _a.replace('/watch/', '');\n            if (!relationId)\n                return;\n            (_b = info.relations) === null || _b === void 0 ? void 0 : _b.push({\n                id: relationId,\n                title: relationAnchor.find('.title').text().trim(),\n                url: `${config.baseUrl}${relationAnchor.attr('href')}`,\n                image: (_e = (_d = (_c = relationAnchor.attr('style')) === null || _c === void 0 ? void 0 : _c.match(/background-image:\\s*url\\('(.+?)'\\)/)) === null || _d === void 0 ? void 0 : _d[1]) !== null && _e !== void 0 ? _e : undefined,\n                japaneseTitle: (_f = relationAnchor.find('.title').attr('data-jp')) === null || _f === void 0 ? void 0 : _f.trim(),\n                type: card.find('.info').children().eq(-2).text().trim(),\n                sub: parseInt(((_g = card.find('.info span.sub')) === null || _g === void 0 ? void 0 : _g.text()) || '0', 10),\n                dub: parseInt(((_h = card.find('.info span.dub')) === null || _h === void 0 ? void 0 : _h.text()) || '0', 10),\n                relationType: card.find('.info').children().last().text().trim(),\n                episodes: parseInt(card.find('.info').children().eq(-3).text().trim() || ((_j = card.find('.info span.sub')) === null || _j === void 0 ? void 0 : _j.text()) || '0', 10) || 0,\n            });\n        });\n        const hasSub = $('.entity-scroll > .info > span.sub').length > 0;\n        const hasDub = $('.entity-scroll > .info > span.dub').length > 0;\n        if (hasSub && hasDub) {\n            info.subOrDub = SubOrDubEnum.BOTH;\n        }\n        else if (hasSub) {\n            info.subOrDub = SubOrDubEnum.SUB;\n        }\n        else if (hasDub) {\n            info.subOrDub = SubOrDubEnum.DUB;\n        }\n        info.hasSub = hasSub;\n        info.hasDub = hasDub;\n        info.genres = [];\n        $('.entity-scroll > .detail')\n            .find(\"div:contains('Genres')\")\n            .each(function () {\n            var _a;\n            const genre = $(this).text().trim();\n            if (genre)\n                (_a = info.genres) === null || _a === void 0 ? void 0 : _a.push(genre);\n        });\n        const statusText = $('.entity-scroll > .detail').find(\"div:contains('Status') > span\").text().trim();\n        switch (statusText) {\n            case 'Completed':\n                info.status = MediaStatusEnum.COMPLETED;\n                break;\n            case 'Releasing':\n                info.status = MediaStatusEnum.ONGOING;\n                break;\n            case 'Not yet aired':\n                info.status = MediaStatusEnum.NOT_YET_AIRED;\n                break;\n            default:\n                info.status = MediaStatusEnum.UNKNOWN;\n                break;\n        }\n        info.season = $('.entity-scroll > .detail').find(\"div:contains('Premiered') > span\").text().trim();\n        const totalEpisodes = $('div.eplist > ul > li').length;\n        info.totalEpisodes = totalEpisodes;\n        const aniId = $('.rate-box#anime-rating').attr('data-id');\n        if (!aniId) {\n            throw new Error('Failed to locate anime id');\n        }\n        const episodeToken = yield GenerateToken(aniId);\n        const episodesResponse = yield axios.get(`${config.baseUrl}/ajax/episodes/list?ani_id=${aniId}&_=${episodeToken}`, {\n            headers: Object.assign({ 'X-Requested-With': 'XMLHttpRequest', 'Referer': `${config.baseUrl}/watch/${id}` }, buildHeaders()),\n        });\n        const $$ = load(episodesResponse.data.result);\n        const subCount = parseInt($('.entity-scroll > .info > span.sub').text().trim() || '0', 10);\n        const dubCount = parseInt($('.entity-scroll > .info > span.dub').text().trim() || '0', 10);\n        info.episodes = [];\n        $$('div.eplist > ul > li > a').each((_, element) => {\n            var _a;\n            const el = $$(element);\n            const href = `${el.attr('href')}ep=${el.attr('num')}` || '';\n            const number = parseInt(el.attr('data-number') || '0', 10);\n            const token = el.attr('token');\n            if (!token)\n                return;\n            const epId = `${info.id}$ep=${el.attr('num')}$token=${token}`;\n            (_a = info.episodes) === null || _a === void 0 ? void 0 : _a.push({\n                id: epId,\n                number,\n                title: el.children('span').text().trim(),\n                isFiller: el.hasClass('filler'),\n                isSubbed: number <= subCount,\n                isDubbed: number <= dubCount,\n                url: `${config.baseUrl}${href}`,\n            });\n        });\n        return info;\n    });\n    const fetchEpisodeServers = (episodeId_1, ...args_1) => __awaiter(this, [episodeId_1, ...args_1], void 0, function* (episodeId, subOrDub = SubOrDubEnum.SUB) {\n        let requestUrl = episodeId;\n        if (!episodeId.startsWith(`${config.baseUrl}/ajax`)) {\n            const token = episodeId.split('$token=')[1];\n            if (!token) {\n                throw new Error('Invalid episodeId format: missing token');\n            }\n            const listToken = yield GenerateToken(token);\n            requestUrl = `${config.baseUrl}/ajax/links/list?token=${token}&_=${listToken}`;\n        }\n        const { data } = yield axios.get(requestUrl, { headers: buildHeaders() });\n        const $ = load(data.result);\n        const servers = [];\n        const subOrDubKey = subOrDub === SubOrDubEnum.SUB ? 'softsub' : 'dub';\n        const serverItems = $(`.server-items.lang-group[data-id=\"${subOrDubKey}\"] .server`);\n        yield Promise.all(serverItems.map((_, server) => __awaiter(this, void 0, void 0, function* () {\n            const serverId = $(server).attr('data-lid');\n            if (!serverId)\n                return;\n            const viewToken = yield GenerateToken(serverId);\n            const { data: linkData } = yield axios.get(`${config.baseUrl}/ajax/links/view?id=${serverId}&_=${viewToken}`, {\n                headers: buildHeaders(),\n            });\n            const decoded = yield DecodeIframeData(linkData.result);\n            servers.push({\n                name: `MegaUp ${$(server).text().trim()}`.toLowerCase(),\n                url: decoded.url,\n                intro: {\n                    start: decoded.skip.intro[0],\n                    end: decoded.skip.intro[1],\n                },\n                outro: {\n                    start: decoded.skip.outro[0],\n                    end: decoded.skip.outro[1],\n                },\n            });\n        })));\n        return servers;\n    });\n    const fetchEpisodeSources = (episodeId_1, ...args_1) => __awaiter(this, [episodeId_1, ...args_1], void 0, function* (episodeId, server = StreamingServersEnum.MegaUp, subOrDub = SubOrDubEnum.SUB) {\n        var _a, _b;\n        if (episodeId.startsWith('http')) {\n            const serverUrl = new PolyURL(episodeId);\n            switch (server) {\n                case StreamingServersEnum.MegaUp:\n                    return Object.assign(Object.assign({ headers: { Referer: serverUrl.href } }, (yield MegaUp().extract(serverUrl))), { download: serverUrl.href.replace(/\\/e\\//, '/download/') });\n                default:\n                    return Object.assign(Object.assign({ headers: { Referer: serverUrl.href } }, (yield MegaUp().extract(serverUrl))), { download: serverUrl.href.replace(/\\/e\\//, '/download/') });\n            }\n        }\n        try {\n            const servers = yield fetchEpisodeServers(episodeId, subOrDub);\n            const i = servers.findIndex((s) => s.name.toLowerCase().includes(server)); //for now only megaup is available, hence directly using it\n            if (i === -1) {\n                throw new Error(`Server ${server} not found`);\n            }\n            const serverUrl = new URL(servers[i].url);\n            const sources = yield fetchEpisodeSources(serverUrl.href, server, subOrDub);\n            sources.intro = (_a = servers[i]) === null || _a === void 0 ? void 0 : _a.intro;\n            sources.outro = (_b = servers[i]) === null || _b === void 0 ? void 0 : _b.outro;\n            return sources;\n        }\n        catch (err) {\n            throw new Error(err.message);\n        }\n    });\n    const GenerateToken = (text) => __awaiter(this, void 0, void 0, function* () {\n        try {\n            const { data } = yield axios.get(`${apiBase}/enc-kai`, {\n                params: { text },\n            });\n            return data.result;\n        }\n        catch (error) {\n            throw new Error(error.message);\n        }\n    });\n    const DecodeIframeData = (payload) => __awaiter(this, void 0, void 0, function* () {\n        try {\n            const { data } = yield axios.post(`${apiBase}/dec-kai`, { text: payload });\n            return data.result;\n        }\n        catch (error) {\n            throw new Error(error.message);\n        }\n    });\n    return {\n        name: config.name,\n        get baseUrl() {\n            return config.baseUrl;\n        },\n        set baseUrl(value) {\n            config.baseUrl = value.startsWith('http') ? value : `http://${value}`;\n        },\n        logo: config.logo,\n        classPath: config.classPath,\n        search,\n        fetchLatestCompleted,\n        fetchRecentlyAdded,\n        fetchRecentlyUpdated,\n        fetchNewReleases,\n        fetchMovie,\n        fetchTV,\n        fetchOVA,\n        fetchONA,\n        fetchSpecial,\n        fetchGenres,\n        genreSearch,\n        fetchSchedule,\n        fetchSpotlight,\n        fetchSearchSuggestions,\n        fetchAnimeInfo,\n        fetchEpisodeSources,\n        fetchEpisodeServers,\n    };\n}\nexports.default = createAnimeKai;\n//# sourceMappingURL=create-animekai.js.map";

export default testCodeString;

// CommonJS compatibility
module.exports = { testCodeString };
