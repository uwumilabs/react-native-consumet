// Auto-generated from test.js
export const testCodeString = "\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction createZoro(ctx, customBaseURL) {\n    const { axios, load, extractors, enums, createCustomBaseUrl, PolyURL } = ctx;\n    const { StreamSB, MegaCloud, StreamTape } = extractors;\n    const { StreamingServers: StreamingServersEnum, SubOrDub: SubOrDubEnum, MediaStatus: MediaStatusEnum, WatchListType: WatchListTypeEnum, } = enums;\n    // Provider configuration - use the standardized base URL creation\n    const baseUrl = createCustomBaseUrl('https://hianime.to', customBaseURL);\n    const config = {\n        name: 'Zoro',\n        languages: 'en',\n        classPath: 'ANIME.Zoro',\n        logo: 'https://hianime.to/images/icons-512.png',\n        baseUrl,\n        isNSFW: false,\n        isWorking: true,\n        isDubAvailableSeparately: true,\n    };\n    // Helper functions\n    const normalizePageNumber = (page) => {\n        return page <= 0 ? 1 : page;\n    };\n    // Main provider functions\n    const search = (query_1, ...args_1) => __awaiter(this, [query_1, ...args_1], void 0, function* (query, page = 1) {\n        const normalizedPage = normalizePageNumber(page);\n        return scrapeCardPage(`${config.baseUrl}/search?keyword=${decodeURIComponent(query)}&page=${normalizedPage}`);\n    });\n    const fetchAdvancedSearch = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1, type, status, rated, score, season, language, startDate, endDate, sort, genres) {\n        const normalizedPage = normalizePageNumber(page);\n        const mappings = {\n            type: { movie: 1, tv: 2, ova: 3, ona: 4, special: 5, music: 6 },\n            status: { finished_airing: 1, currently_airing: 2, not_yet_aired: 3 },\n            rated: { g: 1, pg: 2, pg_13: 3, r: 4, r_plus: 5, rx: 6 },\n            season: { spring: 1, summer: 2, fall: 3, winter: 4 },\n            language: { sub: 1, dub: 2, sub_dub: 3 },\n            genre: {\n                action: 1,\n                adventure: 2,\n                cars: 3,\n                comedy: 4,\n                dementia: 5,\n                demons: 6,\n                mystery: 7,\n                drama: 8,\n                ecchi: 9,\n                fantasy: 10,\n                game: 11,\n                historical: 12,\n                horror: 13,\n                kids: 14,\n                magic: 15,\n                martial_arts: 16,\n                mecha: 17,\n                music: 18,\n                parody: 19,\n                samurai: 20,\n                romance: 21,\n                school: 22,\n                sci_fi: 23,\n                shoujo: 24,\n                shoujo_ai: 25,\n                shounen: 26,\n                shounen_ai: 27,\n                space: 28,\n                sports: 29,\n                super_power: 30,\n                vampire: 31,\n                harem: 32,\n                slice_of_life: 33,\n                supernatural: 34,\n                military: 35,\n                police: 36,\n                psychological: 37,\n                thriller: 38,\n                seinen: 39,\n                josei: 40,\n                isekai: 41,\n            },\n        };\n        const params = new URLSearchParams();\n        params.append('page', normalizedPage.toString());\n        if (type && mappings.type[type]) {\n            params.append('type', mappings.type[type].toString());\n        }\n        if (status && mappings.status[status]) {\n            params.append('status', mappings.status[status].toString());\n        }\n        if (rated && mappings.rated[rated]) {\n            params.append('rated', mappings.rated[rated].toString());\n        }\n        if (score)\n            params.append('score', score.toString());\n        if (season && mappings.season[season]) {\n            params.append('season', mappings.season[season].toString());\n        }\n        if (language && mappings.language[language]) {\n            params.append('language', mappings.language[language].toString());\n        }\n        if (sort)\n            params.append('sort', sort);\n        if (startDate) {\n            params.append('start_date', `${startDate.year}-${startDate.month.toString().padStart(2, '0')}-${startDate.day.toString().padStart(2, '0')}`);\n        }\n        if (endDate) {\n            params.append('end_date', `${endDate.year}-${endDate.month.toString().padStart(2, '0')}-${endDate.day.toString().padStart(2, '0')}`);\n        }\n        if (genres && genres.length > 0) {\n            const genreIds = genres.map((g) => mappings.genre[g]).filter(Boolean);\n            if (genreIds.length > 0) {\n                params.append('genres', genreIds.join(','));\n            }\n        }\n        return scrapeCardPage(`${config.baseUrl}/filter?${params.toString()}`);\n    });\n    const fetchTopAiring = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        const normalizedPage = normalizePageNumber(page);\n        return scrapeCardPage(`${config.baseUrl}/top-airing?page=${normalizedPage}`);\n    });\n    const fetchMostPopular = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        const normalizedPage = normalizePageNumber(page);\n        return scrapeCardPage(`${config.baseUrl}/most-popular?page=${normalizedPage}`);\n    });\n    const fetchMostFavorite = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        const normalizedPage = normalizePageNumber(page);\n        return scrapeCardPage(`${config.baseUrl}/most-favorite?page=${normalizedPage}`);\n    });\n    const fetchLatestCompleted = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        const normalizedPage = normalizePageNumber(page);\n        return scrapeCardPage(`${config.baseUrl}/completed?page=${normalizedPage}`);\n    });\n    const fetchRecentlyUpdated = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        const normalizedPage = normalizePageNumber(page);\n        return scrapeCardPage(`${config.baseUrl}/recently-updated?page=${normalizedPage}`);\n    });\n    const fetchRecentlyAdded = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        const normalizedPage = normalizePageNumber(page);\n        return scrapeCardPage(`${config.baseUrl}/recently-added?page=${normalizedPage}`);\n    });\n    const fetchTopUpcoming = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        const normalizedPage = normalizePageNumber(page);\n        return scrapeCardPage(`${config.baseUrl}/top-upcoming?page=${normalizedPage}`);\n    });\n    const fetchStudio = (studio_1, ...args_1) => __awaiter(this, [studio_1, ...args_1], void 0, function* (studio, page = 1) {\n        const normalizedPage = normalizePageNumber(page);\n        return scrapeCardPage(`${config.baseUrl}/producer/${studio}?page=${normalizedPage}`);\n    });\n    const fetchSubbedAnime = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        const normalizedPage = normalizePageNumber(page);\n        return scrapeCardPage(`${config.baseUrl}/subbed-anime?page=${normalizedPage}`);\n    });\n    const fetchDubbedAnime = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        const normalizedPage = normalizePageNumber(page);\n        return scrapeCardPage(`${config.baseUrl}/dubbed-anime?page=${normalizedPage}`);\n    });\n    const fetchMovie = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        const normalizedPage = normalizePageNumber(page);\n        return scrapeCardPage(`${config.baseUrl}/movie?page=${normalizedPage}`);\n    });\n    const fetchTV = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        const normalizedPage = normalizePageNumber(page);\n        return scrapeCardPage(`${config.baseUrl}/tv?page=${normalizedPage}`);\n    });\n    const fetchOVA = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        const normalizedPage = normalizePageNumber(page);\n        return scrapeCardPage(`${config.baseUrl}/ova?page=${normalizedPage}`);\n    });\n    const fetchONA = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        const normalizedPage = normalizePageNumber(page);\n        return scrapeCardPage(`${config.baseUrl}/ona?page=${normalizedPage}`);\n    });\n    const fetchSpecial = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        const normalizedPage = normalizePageNumber(page);\n        return scrapeCardPage(`${config.baseUrl}/special?page=${normalizedPage}`);\n    });\n    const fetchGenres = (...args_1) => __awaiter(this, [...args_1], void 0, function* (page = 1) {\n        const normalizedPage = normalizePageNumber(page);\n        return scrapeCardPage(`${config.baseUrl}/genre?page=${normalizedPage}`);\n    });\n    const genreSearch = (genre_1, ...args_1) => __awaiter(this, [genre_1, ...args_1], void 0, function* (genre, page = 1) {\n        const normalizedPage = normalizePageNumber(page);\n        return scrapeCardPage(`${config.baseUrl}/genre/${genre}?page=${normalizedPage}`);\n    });\n    const fetchSchedule = (date) => __awaiter(this, void 0, void 0, function* () {\n        try {\n            const response = yield fetch(`${config.baseUrl}/ajax/schedule/list?tzOffset=-330&date=${date}`);\n            const data = yield response.json();\n            const $ = load(data.html);\n            return yield scrapeCard($);\n        }\n        catch (error) {\n            throw new Error(`Failed to fetch schedule: ${error}`);\n        }\n    });\n    const fetchSpotlight = () => __awaiter(this, void 0, void 0, function* () {\n        try {\n            const response = yield fetch(config.baseUrl);\n            const data = yield response.text();\n            const $ = load(data);\n            const results = [];\n            $('.deslide-item').each((_, element) => {\n                var _a, _b, _c;\n                const id = ((_a = $(element).find('a').attr('href')) === null || _a === void 0 ? void 0 : _a.split('/')[1]) || '';\n                const title = $(element).find('.desi-head-title').text().trim();\n                const poster = ((_c = (_b = $(element)\n                    .find('.desi-buttons-wrap .btn-secondary')\n                    .attr('href')) === null || _b === void 0 ? void 0 : _b.match(/url=([^&]+)/)) === null || _c === void 0 ? void 0 : _c[1]) || '';\n                const description = $(element).find('.desi-description').text().trim();\n                if (id) {\n                    results.push({\n                        id,\n                        title,\n                        url: `${config.baseUrl}/${id}`,\n                        image: decodeURIComponent(poster),\n                        description,\n                    });\n                }\n            });\n            return results;\n        }\n        catch (error) {\n            throw new Error(`Failed to fetch spotlight: ${error}`);\n        }\n    });\n    const fetchSearchSuggestions = (query) => __awaiter(this, void 0, void 0, function* () {\n        try {\n            const response = yield fetch(`${config.baseUrl}/ajax/search/suggest?keyword=${encodeURIComponent(query)}`);\n            const data = yield response.json();\n            const $ = load(data.html);\n            return yield scrapeCard($);\n        }\n        catch (error) {\n            throw new Error(`Failed to fetch search suggestions: ${error}`);\n        }\n    });\n    const fetchContinueWatching = () => __awaiter(this, void 0, void 0, function* () {\n        try {\n            const response = yield fetch(`${config.baseUrl}/ajax/home/widget/continue-watching`);\n            const data = yield response.json();\n            const $ = load(data.html);\n            return yield scrapeCard($);\n        }\n        catch (error) {\n            throw new Error(`Failed to fetch continue watching: ${error}`);\n        }\n    });\n    const fetchWatchList = (watchListType) => __awaiter(this, void 0, void 0, function* () {\n        try {\n            const response = yield fetch(`${config.baseUrl}/ajax/user/watchlist/${watchListType}`);\n            const data = yield response.json();\n            const $ = load(data.html);\n            return yield scrapeCard($);\n        }\n        catch (error) {\n            throw new Error(`Failed to fetch watch list: ${error}`);\n        }\n    });\n    const fetchAnimeInfo = (id) => __awaiter(this, void 0, void 0, function* () {\n        try {\n            const animeUrl = `${config.baseUrl}/${id}`;\n            const response = yield fetch(animeUrl);\n            const data = yield response.text();\n            const $ = load(data);\n            const info = {\n                id: id,\n                title: $('.anisc-detail h2.film-name').text().trim(),\n                url: animeUrl,\n                genres: [],\n                totalEpisodes: 0,\n            };\n            info.image = $('.film-poster img').attr('src');\n            info.description = $('.film-description .text').text().trim();\n            // Extract genres\n            $('.item-list a[href*=\"/genre/\"]').each((_, el) => {\n                var _a;\n                (_a = info.genres) === null || _a === void 0 ? void 0 : _a.push($(el).text().trim());\n            });\n            // Extract other info from the info list\n            $('.anisc-info .item').each((_, item) => {\n                const label = $(item).find('.item-head').text().trim().toLowerCase();\n                const value = $(item).find('.name').text().trim() || $(item).text().replace($(item).find('.item-head').text(), '').trim();\n                if (label.includes('studio'))\n                    info.studios = [value];\n                if (label.includes('duration'))\n                    info.duration = value;\n                if (label.includes('status')) {\n                    switch (value) {\n                        case 'Finished Airing':\n                            info.status = MediaStatusEnum.COMPLETED;\n                            break;\n                        case 'Currently Airing':\n                            info.status = MediaStatusEnum.ONGOING;\n                            break;\n                        case 'Not yet aired':\n                            info.status = MediaStatusEnum.NOT_YET_AIRED;\n                            break;\n                        default:\n                            info.status = MediaStatusEnum.UNKNOWN;\n                            break;\n                    }\n                }\n                if (label.includes('type'))\n                    info.type = value;\n                if (label.includes('score'))\n                    info.rating = parseFloat(value);\n                if (label.includes('premiered'))\n                    info.releaseDate = value;\n                if (label.includes('japanese'))\n                    info.japaneseTitle = value;\n            });\n            // Check for sub/dub availability\n            const hasSub = $('div.film-stats div.tick div.tick-item.tick-sub').length > 0;\n            const hasDub = $('div.film-stats div.tick div.tick-item.tick-dub').length > 0;\n            if (hasSub) {\n                info.subOrDub = SubOrDubEnum.SUB;\n                info.hasSub = hasSub;\n            }\n            if (hasDub) {\n                info.subOrDub = SubOrDubEnum.DUB;\n                info.hasDub = hasDub;\n            }\n            if (hasSub && hasDub) {\n                info.subOrDub = SubOrDubEnum.BOTH;\n            }\n            // Fetch episodes\n            const episodesResponse = yield fetch(`${config.baseUrl}/ajax/v2/episode/list/${id.split('-').pop()}`, {\n                headers: {\n                    'X-Requested-With': 'XMLHttpRequest',\n                    'Referer': `${config.baseUrl}/watch/${id}`,\n                },\n            });\n            const episodesData = yield episodesResponse.json();\n            const $$ = load(episodesData.html);\n            const episodeElements = $$('div.detail-infor-content > div > a');\n            const subCount = parseInt($('div.film-stats div.tick div.tick-item.tick-sub').text().trim()) || 0;\n            const dubCount = parseInt($('div.film-stats div.tick div.tick-item.tick-dub').text().trim()) || 0;\n            info.totalEpisodes = episodeElements.length;\n            info.episodes = [];\n            episodeElements.each((i, el) => {\n                var _a, _b;\n                const $el = $$(el);\n                const href = $el.attr('href') || '';\n                const number = parseInt($el.attr('data-number') || '0');\n                (_a = info.episodes) === null || _a === void 0 ? void 0 : _a.push({\n                    id: ((_b = href.split('/')[2]) === null || _b === void 0 ? void 0 : _b.replace('?ep=', '$episode$')) || '',\n                    number: number,\n                    title: $el.attr('title'),\n                    isFiller: $el.hasClass('ssl-item-filler'),\n                    isSubbed: number <= subCount,\n                    isDubbed: number <= dubCount,\n                    url: config.baseUrl + href,\n                });\n            });\n            return info;\n        }\n        catch (err) {\n            throw new Error(err.message);\n        }\n    });\n    const fetchEpisodeSources = (episodeId_1, ...args_1) => __awaiter(this, [episodeId_1, ...args_1], void 0, function* (episodeId, server = StreamingServersEnum.MegaCloud, subOrDub = SubOrDubEnum.SUB) {\n        if (episodeId.startsWith('http')) {\n            const serverUrl = new PolyURL(episodeId);\n            switch (server) {\n                case StreamingServersEnum.MegaCloud:\n                    return Object.assign({ headers: { Referer: serverUrl.href } }, (yield MegaCloud().extract(serverUrl, config.baseUrl)));\n                default:\n                    return Object.assign({ headers: { Referer: serverUrl.href } }, (yield MegaCloud().extract(serverUrl, config.baseUrl)));\n            }\n        }\n        if (!episodeId.includes('$episode$'))\n            throw new Error('Invalid episode id');\n        episodeId = `${config.baseUrl}/watch/${episodeId.replace('$episode$', '?ep=').replace(/\\$auto|\\$sub|\\$dub/gi, '')}`;\n        try {\n            const servers = yield fetchEpisodeServers(episodeId.split('?ep=')[1], subOrDub);\n            const i = servers.findIndex((s) => s.name.toLowerCase().includes(server));\n            if (i === -1) {\n                throw new Error(`Server ${server} not found`);\n            }\n            const serverUrl = new URL(servers[i].url);\n            return yield fetchEpisodeSources(serverUrl.href, server, SubOrDubEnum.SUB);\n        }\n        catch (err) {\n            throw err;\n        }\n    });\n    const fetchEpisodeServers = (episodeId, subOrDub) => __awaiter(this, void 0, void 0, function* () {\n        try {\n            if (episodeId.includes('$episode$'))\n                episodeId = episodeId.split('$episode$')[1];\n            const response = yield fetch(`${config.baseUrl}/ajax/v2/episode/servers?episodeId=${episodeId}`);\n            const data = yield response.json();\n            const $ = load(data.html);\n            const scrapedServers = [];\n            let selector;\n            try {\n                selector = `.ps_-block.ps_-block-sub.servers-${false ? 'raw' : subOrDub} > .ps__-list .server-item`;\n            }\n            catch (_a) {\n                selector = `.ps_-block.ps_-block-sub.servers-${true ? 'raw' : subOrDub} > .ps__-list .server-item`;\n            }\n            $(selector).each((_, element) => {\n                const name = $(element).text().trim();\n                const sourcesId = $(element).attr('data-id') || '';\n                const subOrDubValue = $(element).attr('data-type') === 'sub' ? SubOrDubEnum.SUB : SubOrDubEnum.DUB;\n                scrapedServers.push({\n                    name,\n                    sourcesId,\n                    subOrDub: subOrDubValue,\n                });\n            });\n            const servers = yield Promise.all(scrapedServers.map((server) => __awaiter(this, void 0, void 0, function* () {\n                const { data } = yield axios.get(`https://hianime.to/ajax/v2/episode/sources?id=${server.sourcesId}`);\n                return {\n                    name: `megacloud-${server.name.toLowerCase()}`,\n                    url: data.link,\n                };\n            })));\n            return servers;\n        }\n        catch (error) {\n            throw new Error(`Failed to fetch episode servers: ${error}`);\n        }\n    });\n    const verifyLoginState = (connectSid) => __awaiter(this, void 0, void 0, function* () {\n        try {\n            const headers = {};\n            if (connectSid) {\n                headers.Cookie = `connect.sid=${connectSid}`;\n            }\n            const response = yield fetch(`${config.baseUrl}/ajax/login-state`, { headers });\n            const data = yield response.json();\n            return data.is_login;\n        }\n        catch (err) {\n            return false;\n        }\n    });\n    const scrapeCard = ($) => __awaiter(this, void 0, void 0, function* () {\n        try {\n            const results = [];\n            $('.flw-item').each((i, ele) => {\n                var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n                const card = $(ele);\n                const atag = card.find('.film-name a');\n                const id = (_a = atag.attr('href')) === null || _a === void 0 ? void 0 : _a.split('/')[1].split('?')[0];\n                const watchList = card.find('.dropdown-menu .added').text().trim();\n                const type = (_c = (_b = card\n                    .find('.fdi-item')) === null || _b === void 0 ? void 0 : _b.first()) === null || _c === void 0 ? void 0 : _c.text().replace(' (? eps)', '').replace(/\\s\\(\\d+ eps\\)/g, '');\n                results.push({\n                    id: id,\n                    title: atag.text(),\n                    url: `${config.baseUrl}${atag.attr('href')}`,\n                    image: (_d = card.find('img')) === null || _d === void 0 ? void 0 : _d.attr('data-src'),\n                    duration: (_e = card.find('.fdi-duration')) === null || _e === void 0 ? void 0 : _e.text(),\n                    watchList: watchList || WatchListTypeEnum.NONE,\n                    japaneseTitle: atag.attr('data-jname'),\n                    type: type,\n                    nsfw: ((_f = card.find('.tick-rate')) === null || _f === void 0 ? void 0 : _f.text()) === '18+' ? true : false,\n                    sub: parseInt((_g = card.find('.tick-item.tick-sub')) === null || _g === void 0 ? void 0 : _g.text()) || 0,\n                    dub: parseInt((_h = card.find('.tick-item.tick-dub')) === null || _h === void 0 ? void 0 : _h.text()) || 0,\n                    episodes: parseInt((_j = card.find('.tick-item.tick-eps')) === null || _j === void 0 ? void 0 : _j.text()) || 0,\n                });\n            });\n            return results;\n        }\n        catch (err) {\n            //console.log(err);\n            throw new Error(`Failed to scrape card: ${err}`);\n        }\n    });\n    const scrapeCardPage = (url, headers) => __awaiter(this, void 0, void 0, function* () {\n        var _a, _b, _c;\n        try {\n            const res = {\n                currentPage: 0,\n                hasNextPage: false,\n                totalPages: 0,\n                results: [],\n            };\n            const response = yield fetch(url, headers);\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status} ${response.statusText} for ${url}`);\n            }\n            const data = yield response.text();\n            const $ = load(data);\n            const pagination = $('ul.pagination');\n            res.currentPage = parseInt((_a = pagination.find('.page-item.active')) === null || _a === void 0 ? void 0 : _a.text());\n            const nextPage = (_b = pagination.find('a[title=Next]')) === null || _b === void 0 ? void 0 : _b.attr('href');\n            if (nextPage !== undefined && nextPage !== '') {\n                res.hasNextPage = true;\n            }\n            const totalPages = (_c = pagination.find('a[title=Last]').attr('href')) === null || _c === void 0 ? void 0 : _c.split('=').pop();\n            if (totalPages === undefined || totalPages === '') {\n                res.totalPages = res.currentPage;\n            }\n            else {\n                res.totalPages = parseInt(totalPages);\n            }\n            res.results = yield scrapeCard($);\n            if (res.results.length === 0) {\n                res.currentPage = 0;\n                res.hasNextPage = false;\n                res.totalPages = 0;\n            }\n            return res;\n        }\n        catch (err) {\n            console.error('scrapeCardPage error:', err);\n            throw new Error(`Failed to scrape page ${url}: ${err instanceof Error ? err.message : 'Unknown error'}`);\n        }\n    });\n    // Return the functional provider object\n    return {\n        // Configuration\n        name: config.name,\n        get baseUrl() {\n            return config.baseUrl;\n        },\n        set baseUrl(value) {\n            config.baseUrl = value.startsWith('http') ? value : `http://${value}`;\n        },\n        logo: config.logo,\n        classPath: config.classPath,\n        // Core methods, pass only the necessary methods, dont pass helpers or unused methods\n        search,\n        fetchAdvancedSearch,\n        fetchTopAiring,\n        fetchMostPopular,\n        fetchMostFavorite,\n        fetchLatestCompleted,\n        fetchRecentlyUpdated,\n        fetchRecentlyAdded,\n        fetchTopUpcoming,\n        fetchStudio,\n        fetchSubbedAnime,\n        fetchDubbedAnime,\n        fetchMovie,\n        fetchTV,\n        fetchOVA,\n        fetchONA,\n        fetchSpecial,\n        fetchGenres,\n        genreSearch,\n        fetchSchedule,\n        fetchSpotlight,\n        fetchSearchSuggestions,\n        fetchContinueWatching,\n        fetchWatchList,\n        fetchAnimeInfo,\n        fetchEpisodeSources,\n        fetchEpisodeServers,\n    };\n}\n// Default export for backward compatibility\nexports.default = createZoro;\n//# sourceMappingURL=create-zoro.js.map";

export default testCodeString;

// CommonJS compatibility  
module.exports = { testCodeString };