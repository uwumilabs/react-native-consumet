// Auto-generated from test.js
export const testCodeString = "\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction createAnimePahe(ctx, customBaseURL) {\n    const { axios, load, extractors, enums, createCustomBaseUrl, PolyURL, NativeConsumet } = ctx;\n    const { Kwik } = extractors;\n    const { StreamingServers: StreamingServersEnum, SubOrDub: SubOrDubEnum, MediaStatus: MediaStatusEnum } = enums;\n    const { getDdosGuardCookiesWithWebView, multiply, bypassDdosGuard } = NativeConsumet;\n    // Provider configuration - use the standardized base URL creation\n    const baseUrl = createCustomBaseUrl('https://animepahe.si', customBaseURL);\n    const config = {\n        name: 'Zoro',\n        languages: 'en',\n        classPath: 'ANIME.Zoro',\n        logo: 'https://is3-ssl.mzstatic.com/image/thumb/Purple112/v4/7e/91/00/7e9100ee-2b62-0942-4cdc-e9b93252ce1c/source/512x512bb.jpg',\n        baseUrl,\n        isNSFW: false,\n        isWorking: true,\n        isDubAvailableSeparately: true,\n    };\n    let ddgCookie = null;\n    const initDdgCookie = () => __awaiter(this, void 0, void 0, function* () {\n        try {\n            try {\n                ddgCookie = yield getDdosGuardCookiesWithWebView(config.baseUrl);\n                // console.log('DDoS-Guard cookie obtained (WebView):', ans,ddgCookie);\n            }\n            catch (err) {\n                console.error('Failed to bypass DDoS-Guard with WebView:', err);\n            }\n        }\n        catch (error) {\n            console.error('Failed to initialize DDoS-Guard cookie:', error);\n        }\n    });\n    function Headers(sessionId) {\n        const headers = {\n            'authority': 'animepahe.ru',\n            'accept': 'application/json, text/javascript, */*; q=0.01',\n            'sec-ch-ua': '\"Not A(Brand\";v=\"99\", \"Microsoft Edge\";v=\"121\", \"Chromium\";v=\"121\"',\n            'sec-ch-ua-mobile': '?0',\n            'sec-ch-ua-platform': '\"Windows\"',\n            'sec-fetch-dest': 'empty',\n            'sec-fetch-mode': 'cors',\n            'sec-fetch-site': 'same-origin',\n            'x-requested-with': 'XMLHttpRequest',\n            'Referer': sessionId ? `${config.baseUrl}/anime/${sessionId}` : `${config.baseUrl}`,\n            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36',\n        };\n        if (ddgCookie) {\n            headers.Cookie = typeof ddgCookie === 'object' && ddgCookie !== null ? ddgCookie.cookie : ddgCookie || '';\n        }\n        return headers;\n    }\n    const fetchEpisodes = (session, page) => __awaiter(this, void 0, void 0, function* () {\n        const res = yield axios.get(`${config.baseUrl}/api?m=release&id=${session}&sort=episode_asc&page=${page}`, {\n            headers: Headers(session),\n        });\n        const epData = res.data.data;\n        return [\n            ...epData.map((item) => ({\n                id: `${session}/${item.session}`,\n                number: item.episode,\n                title: item.title,\n                image: item.snapshot,\n                duration: item.duration,\n                isSubbed: item.audio === 'jpn' || item.audio === 'eng',\n                isDubbed: item.audio === 'eng',\n                releaseDate: item.created_at,\n                url: `${config.baseUrl}/play/${session}/${item.session}`,\n            })),\n        ];\n    });\n    const search = (query_1, ...args_1) => __awaiter(this, [query_1, ...args_1], void 0, function* (query, page = 1) {\n        try {\n            if (!ddgCookie) {\n                yield initDdgCookie();\n            }\n            const { data } = yield axios.get(`${config.baseUrl}/api?m=search&q=${encodeURIComponent(query)}`, {\n                headers: Headers(false),\n            });\n            const res = {\n                results: data.data.map((item) => ({\n                    id: item.session,\n                    title: item.title,\n                    image: item.poster,\n                    rating: item.score,\n                    releaseDate: item.year,\n                    type: item.type,\n                })),\n            };\n            return res;\n        }\n        catch (err) {\n            //console.log(err);\n            throw new Error(err.message);\n        }\n    });\n    const fetchAnimeInfo = (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, episodePage = -1) {\n        const animeInfo = {\n            id: id,\n            title: '',\n        };\n        try {\n            if (!ddgCookie) {\n                yield initDdgCookie();\n            }\n            const res = yield fetch(`${config.baseUrl}/anime/${id}`, {\n                headers: Headers(id),\n            });\n            const data = yield res.text();\n            const $ = load(data);\n            animeInfo.title = $('div.title-wrapper > h1 > span').first().text();\n            animeInfo.image = $('div.anime-poster a').attr('href');\n            animeInfo.cover = `https:${$('div.anime-cover').attr('data-src')}`;\n            animeInfo.description = $('div.anime-summary').text().trim();\n            animeInfo.genres = $('div.anime-genre ul li')\n                .map((i, el) => $(el).find('a').attr('title'))\n                .get();\n            animeInfo.hasSub = true;\n            switch ($('div.anime-info p:icontains(\"Status:\") a').text().trim()) {\n                case 'Currently Airing':\n                    animeInfo.status = MediaStatusEnum.ONGOING;\n                    break;\n                case 'Finished Airing':\n                    animeInfo.status = MediaStatusEnum.COMPLETED;\n                    break;\n                default:\n                    animeInfo.status = MediaStatusEnum.UNKNOWN;\n            }\n            animeInfo.type = $('div.anime-info > p:contains(\"Type:\") > a').text().trim().toUpperCase();\n            animeInfo.releaseDate = $('div.anime-info > p:contains(\"Aired:\")')\n                .text()\n                .split('to')[0]\n                .replace('Aired:', '')\n                .trim();\n            animeInfo.studios = $('div.anime-info > p:contains(\"Studio:\")').text().replace('Studio:', '').trim().split('\\n');\n            animeInfo.totalEpisodes = parseInt($('div.anime-info > p:contains(\"Episodes:\")').text().replace('Episodes:', ''));\n            animeInfo.recommendations = [];\n            $('div.anime-recommendation .col-sm-6').each((i, el) => {\n                var _a, _b, _c;\n                (_a = animeInfo.recommendations) === null || _a === void 0 ? void 0 : _a.push({\n                    id: (_b = $(el).find('.col-2 > a').attr('href')) === null || _b === void 0 ? void 0 : _b.split('/')[2],\n                    title: $(el).find('.col-2 > a').attr('title'),\n                    image: $(el).find('.col-2 > a > img').attr('src') || $(el).find('.col-2 > a > img').attr('data-src'),\n                    url: `${config.baseUrl}/anime/${(_c = $(el).find('.col-2 > a').attr('href')) === null || _c === void 0 ? void 0 : _c.split('/')[2]}`,\n                    releaseDate: $(el).find('div.col-9 > a').text().trim(),\n                    status: $(el).find('div.col-9 > strong').text().trim(),\n                });\n            });\n            animeInfo.relations = [];\n            $('div.anime-relation .col-sm-6').each((i, el) => {\n                var _a, _b, _c;\n                (_a = animeInfo.relations) === null || _a === void 0 ? void 0 : _a.push({\n                    id: (_b = $(el).find('.col-2 > a').attr('href')) === null || _b === void 0 ? void 0 : _b.split('/')[2],\n                    title: $(el).find('.col-2 > a').attr('title'),\n                    image: $(el).find('.col-2 > a > img').attr('src') || $(el).find('.col-2 > a > img').attr('data-src'),\n                    url: `${config.baseUrl}/anime/${(_c = $(el).find('.col-2 > a').attr('href')) === null || _c === void 0 ? void 0 : _c.split('/')[2]}`,\n                    releaseDate: $(el).find('div.col-9 > a').text().trim(),\n                    status: $(el).find('div.col-9 > strong').text().trim(),\n                    relationType: $(el).find('h4 > span').text().trim(),\n                });\n            });\n            animeInfo.episodes = [];\n            if (episodePage < 0) {\n                const { data: { last_page, data }, } = yield axios.get(`${config.baseUrl}/api?m=release&id=${id}&sort=episode_asc&page=1`, {\n                    headers: Headers(id),\n                });\n                animeInfo.episodePages = last_page;\n                animeInfo.episodes.push(...data.map((item) => ({\n                    id: `${id}/${item.session}`,\n                    number: item.episode,\n                    title: item.title,\n                    image: item.snapshot,\n                    duration: item.duration,\n                    isSubbed: item.audio === 'jpn' || item.audio === 'eng',\n                    isDubbed: item.audio === 'eng',\n                    releaseDate: item.created_at,\n                    url: `${config.baseUrl}/play/${id}/${item.session}`,\n                })));\n                for (let i = 1; i < last_page; i++) {\n                    animeInfo.episodes.push(...(yield fetchEpisodes(id, i + 1)));\n                }\n            }\n            else {\n                animeInfo.episodes.push(...(yield fetchEpisodes(id, episodePage)));\n            }\n            return animeInfo;\n        }\n        catch (err) {\n            throw new Error(err.message);\n        }\n    });\n    const fetchEpisodeSources = (episodeId_1, ...args_1) => __awaiter(this, [episodeId_1, ...args_1], void 0, function* (episodeId, server = StreamingServersEnum.Kwik, subOrDub = SubOrDubEnum.SUB) {\n        if (episodeId.startsWith('http')) {\n            const serverUrl = new PolyURL(episodeId);\n            switch (server) {\n                case StreamingServersEnum.Kwik:\n                    return Object.assign({ headers: { Referer: serverUrl.href } }, (yield Kwik().extract(serverUrl, config.baseUrl)));\n                default:\n                    return Object.assign({ headers: { Referer: serverUrl.href } }, (yield Kwik().extract(serverUrl, config.baseUrl)));\n            }\n        }\n        try {\n            if (!ddgCookie) {\n                yield initDdgCookie();\n            }\n            const { data } = yield axios.get(`${config.baseUrl}/play/${episodeId}`, {\n                headers: Headers(episodeId.split('/')[0]),\n            });\n            const $ = load(data);\n            const downloads = $('div#pickDownload > a')\n                .map((i, el) => ({\n                url: $(el).attr('href'),\n                quality: $(el).text(),\n            }))\n                .get();\n            const iSource = {\n                headers: {\n                    Referer: 'https://kwik.si/',\n                },\n                sources: [],\n            };\n            iSource.download = downloads;\n            const servers = yield fetchEpisodeServers(episodeId, subOrDub);\n            const i = servers.findIndex((s) => s.name.toLowerCase().includes(server));\n            if (i === -1) {\n                throw new Error(`Server ${server} not found`);\n            }\n            const serverUrl = new URL(servers[i].url);\n            return yield fetchEpisodeSources(serverUrl.href, server, subOrDub);\n        }\n        catch (err) {\n            console.log(err);\n            throw new Error(err.message);\n        }\n    });\n    const fetchEpisodeServers = (episodeId, subOrDub) => __awaiter(this, void 0, void 0, function* () {\n        try {\n            if (!ddgCookie) {\n                yield initDdgCookie();\n            }\n            const { data } = yield axios.get(`${config.baseUrl}/play/${episodeId}`, {\n                headers: Headers(episodeId.split('/')[0]),\n            });\n            const $ = load(data);\n            const servers = [];\n            $('div#resolutionMenu > button').each((i, el) => {\n                const audio = $(el).attr('data-audio');\n                const fansub = $(el).attr('data-fansub');\n                const src = $(el).attr('data-src');\n                const resolution = $(el).attr('data-resolution');\n                if ((subOrDub === SubOrDubEnum.DUB && audio === 'eng') || (subOrDub === SubOrDubEnum.SUB && audio !== 'eng')) {\n                    servers.push({\n                        url: src,\n                        name: `kwik-${fansub}-${resolution}`,\n                    });\n                }\n            });\n            return servers;\n        }\n        catch (err) {\n            console.log(err);\n            throw new Error(err.message);\n        }\n    });\n    // Return the functional provider object\n    return {\n        // Configuration\n        name: config.name,\n        get baseUrl() {\n            return config.baseUrl;\n        },\n        set baseUrl(value) {\n            config.baseUrl = value.startsWith('http') ? value : `http://${value}`;\n        },\n        logo: config.logo,\n        classPath: config.classPath,\n        // Core methods, pass only the necessary methods, dont pass helpers or unused methods\n        search,\n        fetchAnimeInfo,\n        fetchEpisodeSources,\n        fetchEpisodeServers,\n    };\n}\n// Default export for backward compatibility\nexports.default = createAnimePahe;\n//# sourceMappingURL=create-animepahe.js.map";

export default testCodeString;

// CommonJS compatibility  
module.exports = { testCodeString };